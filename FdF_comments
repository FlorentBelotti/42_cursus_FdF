/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   FdF_comments                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fbelotti <marvin@42perpignan.fr>           +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/08 16:01:07 by fbelotti          #+#    #+#             */
/*   Updated: 2024/03/08 16:31:49 by fbelotti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*

> Si j'utilise 'exit' en cas d'erreur, peut-être faut-il que je close(fd)
avant... À voir plus tard.

> Avant parse_line dans get_and_parse_line, je devrais rajouter une gestion d'
erreur type 'check_line' pour vérifier que : 1) Le premier caractère de la ligne
est un nombre 2) que les valeurs sont séparées par des espaces 3) que les codes
couleurs, s'ils existent, sont au bon format 4) que les caractères sont valides
en général, c'est-à-dire des valeurs ou un code couleur 5) qu'il y a autant
d'élément dans la ligne précédente que dans la nouvelle ligne.

-> Finalement on vérifiera les éléments de la liste...

-> Dans 'line_error', rajouter une fonction qui parcours la chaine, et vérifie
que la succession des char correspond à l'ordre adéquat (valeur valeur ou
valeur,color_code);

int	count_lines(char *file_name)
{
	int		fd;
	int		line_nb;
	char	*line;

	line = 0;
	fd = open(file_name, O_RDONLY);
	line = get_next_line(fd);
	while (line != NULL)
	{
		line_nb++;
		free(line);
		line = get_next_line(fd);
	}
	close(fd);
	return (line_nb);
} */
